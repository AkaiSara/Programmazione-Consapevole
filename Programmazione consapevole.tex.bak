\documentclass[a4paper,12pt]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,italian]{babel}
\usepackage{geometry}
\geometry{a4paper,top=2.5cm,bottom=2.5cm,left=2.5cm,right=3cm,heightrounded,bindingoffset=5mm}
\raggedbottom

\usepackage{listings} %Per inserire codice
\usepackage[usenames]{color} %Per permettere la colorazione dei caratteri 
\definecolor{orange}{rgb}{1,0.647,0}
\definecolor{cornflowerblue}{rgb}{0.392,0.584,0.929}
\lstnewenvironment{codice}[1]
{	\lstset
	{	basicstyle=\ttfamily,
		columns=fullflexible,				
		basicstyle=\footnotesize \ttfamily,
  		keywordstyle=\bfseries\color{orange},
 		%commentstyle=\itshape\color{purple},
  		%identifierstyle=\color{cyano},
 		stringstyle=\color{cornflowerblue},
		language=C++,
		%float,
		showstringspaces=false
	}
	\lstset
	{	numbers=left,
		numberstyle=\tiny,
		stepnumber=1,
		numbersep=15pt
	}
}
{}


\begin{document}

\author{Andrea Salmaso}
\title{Programmazione consapevole \\ (semplice è bello)}
\maketitle

\tableofcontents

\newpage

\paragraph{Prefazione}
Lo scopo del libro è duplice. In primo luogo si propone di insegnare un linguaggio di programmazione semplice e popolare e in secondo luogo, intende sviluppare nei lettori la capacità di usare la programmazione in modo scientifico per risolvere problemi. Questo significa, in primo luogo, definire in modo preciso  problemi da affrontare e successivamente spiegare, in modo altrettanto chiaro, perché i programmi proposti per risolverli effettivamente lo fanno. Il linguaggio di programmazione è C++ senza la parte orientata agli oggetti. In pratica si tratta del linguaggio C con alcune caratteristiche aggiuntive che lo rendono più facile da usare rispetto al semplice C.

Il libro non assume alcuna conoscenza preliminare di Informatica ed è quindi pensato per un corso iniziale di programmazione, sia in una scuola superiore, sia nella Laurea (triennale) in Informatica o in Ingegneria Informatica. Il testo abbonda di esercizi, sia risolti che aperti. Ogni programma presentato nel libro è accompagnato da una dimostrazione di correttezza intuitiva, ma anche ragionevolmente precisa. La programmazione ricorsiva viene trattata diffusamente e la correttezza dei programmi ricorsivi viene dimostrata usando l'induzione.

\chapter{Introduzione}
\section{Struttura di un computer}
\section{Come scrivere ed eseguire un programma}
\section{Notazione}

\chapter{Tipi predefiniti e variabili}
\section{Tipi predefiniti}
\section{Variabili e dichiarazioni}
\section{Espressioni e conversioni}
\section{A cosa servono i tipi}

\chapter{Istruzioni di base}
Questo capitolo è dedicato alla descrizione delle istruzioni di base del C e C++.

\noindent Chiariamo subito che queste istruzioni si trovano in qualsiasi linguaggio di programmazione della grande famiglia dei linguaggi imperativi, come per esempio Fortran, Pascal, ma anche quelli orientati ad oggetti come C++, Java eccetera.

\noindent Tratteremo in primo luogo le istruzioni di input e di output e successivamente esamineremo l'assegnazione, il comando condizionale ed il comando iterativo \texttt{while}.

In generale un'istruzione ha l'effetto di modificare il valore di qualche variabile.
Per evitare di creare malintesi chiariamo subito che una variabile in programmazione ha due valori: l'R- e l'L-valore. L'R-valore è quello che viene informalmente chiamato valore e che (normalmente) è un valore del tipo della variabile in questione.
L'R-valore viene però immagazzinato in memoria e l'L-valore di una variabile è l'indirizzo della memoria in cui l'R-valore è immagazzinato.

Nel seguito, per spiegare il significato delle istruzioni, useremo spesso la nozione di \textbf{stato del calcolo} che spiega l'R-valore di tutte le variabili in un dato momento.
Più formalmente, lo stato del calcolo in un dato momento dell'esecuzione è rappresentato da una funzione \textbf{S} tale che ogni variabile attiva \texttt{x} del programma, \textbf{S}(x) è l'R-valore di \texttt{x} in quel momento.
Il caso che \texttt{x} sia indefinita viene rappresentato con \textbf{S}(x)=$\perp$.
Il significato di ogni istruzione può venire specificato attraverso le modifiche che l'istruzione opera sullo stato del calcolo.

\section{Input/Otput}
I programmi devono poter scambiare informazioni con l'esterno ed a questo servono le operazioni di lettura e stampa, dette di input/output e abbreviate in i/o.

\noindent Ci limiteremo a spiegare le operazioni più semplici che poi useremo sempre nel seguito del testo.
Operazioni di i/o maggiormente sofisticate sono descritte in www.cplusplus.com.
Un programma comunica con l'esterno per mezzo di dispositivi molto diversi: in un computer moderno, l'input standard è la tastiera, l'output standard è lo schermo, ma un programma potrebbe poter scrivere o leggere da un dispositivo USB o da CD o DVD o semplicemente da un file nella memoria del computer o anche un file che risiede nella memoria di qualche altro computer raggiungibile d quello su cui il programma esegue.
Sarebbe troppo complicato se ci fossero istruzioni di i/o distinte per ciascun dispositivo.
Quindi tutti questi dispositivi vengono visti dai programmi nello stesso modo: come un \textbf{file}
Vediamo innanzitutto cos'è un file, successivamente ci occuperemo di come un programma acceda a un file e delle principali operazioni di i/o disponibili.

\subsection{I file}
Concettualmente un file è una sequenza di dati che terminano con un carattere particolare, detto \textbf{end of file}. Ci sono 2 tipi di file: file di \textbf{testo} e file \textbf{binari}. Un file di testo è costituito da una sequenza di byte ognuno dei quali rappresenta un carattere, contiene cioè la codifica ASCII estesa di un carattere. Questi file in generale contengono un testo, per esempio un programma o un romanzo. Dato che ciascun carattere è rappresentato dalla sua codifica ASCII estesa, per leggere il testo contenuto in un file di testo, è necessario usare un programma che traduce ciascun byte nel corrispondente carattere scritto sullo schermo. Un esempio di un tale programma è un editore di testo. 

I file \textbf{binari} sono ancora sequenze di byte (tutto è una sequenza di byte in un computer), ma questi byte non sono codifiche di caratteri, ma sono rappresentazioni interne al computer di valori, per esempio valori interi, reali eccetera. Ovviamente nel computer i valori di tipo carattere sono rappresentati sempre con il codice ASCII esteso e quindi un file di testo e binario che contengono valori di tipo carattere sono (fondamentalmente) uguali. Al contrario, se i valori contenuti in un file binario sono per esempio interi, se si cerca di leggerlo con un editore di testo, si ottiene sullo schermo un testo assolutamente incomprensibile. Nonostante che sequenza di 8 bit possa venire interpretata come il codice di un carattere secondo la codifica ASCII estesa, la sequenza dei caratteri ottenuti traducendo in questo modo un file binario, sarà senza senso. 

Facciamo un semplice esempio per chiarire la differenza tra file di testo e file binari. Consideriamo il valore intero 8. In un file di testo il valore 8 viene rappresentato da un solo byte che contiene la codifica ASCII estesa del carattere '8', cioè 56 (per la precisione il valore binario 00111000), mentre in un file binario il valore 8 è rappresentato da 4 byte come ogni valore intero, cf. Tabella 2.1: i primi 3 composti da tutti O, mentre il quarto conterrebbe: \texttt{00001000}, cioè la codifica binaria di 8. Il valore -8 verrebbe rappresentato su un file di testo da 2 byte (uno che contiene la codifica ASCII estesa di '-' e l'altro quella di '8'), mentre in un file binario verrebbe rappresentato ancora da 4 byte che rappresentano in binario il valore 4294967288, che è la rappresentazione in complemento a 2 dell'intero -8, cioè 2\ap{32}-8.

Comunque ogni file è una sequenza di byte e, generalmente, la lettura di un file inizia sempre dal primo byte e successive letture leggono i byte successivi. Vedremo che è possibile leggere un byte alla volta e anche molti byte alla volta. Comunque, se, dopo alcune letture, si raggiunge l'end of file, significa che il contenuto del file è stato completamente letto. Questo modo di procedere si dice \textbf{sequenziale}. Esistono anche altre modalità di lettura non sequenziali (random) di cui non ci occuperemo. L'output inizia generalmente con un file vuoto e ogni operazione di scrittura sul file aggiunge byte in modo sequenziale, cioè successivi valori scritti sul file vengono appesi in coda a quelli scritti precedentemente In questo testo ci occuperemo solo di file di testo che sono letti e scritti in modo sequenziale. Sono più semplici e sono anche quelli usati più frequentemente.

\subsection{Collegamento tra programma e file}
Il collegamento tra un programma ed un file avviene associando al file un oggetto di tipo \texttt{stream}. Trattandosi di oggetti, nel seguito spiegheremo solo come usare gli \texttt{stream}, senza entrare nei dettagli. Un oggetto contiene dati e offre funzioni (dette \textbf{metodi}) per manipolare questi dati. Nel caso degli \texttt{stream} i metodi offerti sono le operazioni di i/o sui file. Per usare un file in un programma si devono inserire alcune istruzioni nel programma: 

\begin{enumerate}
\item[i)]	all'inizio del programma va inserita la direttiva \texttt{\#include<fstream>},

\item[ii)]	inserendo, per esempio nel main, la dichiarazione,

\noindent \texttt{ifstream XX(''pippo'');}
			
\noindent si crea lo \texttt{stream XX} che viene associato al file pippo, il quale vie­ne simultaneamente \textbf{aperto} per eseguire input, cioè i suoi dati sono ora a disposizione del nostro programma per operazioni sequenziali di lettura;

\item[iii)]	per aprire il file \texttt{minni} in output, cioè per scriverci sopra, si deve inserire nel programma la dichiarazione: \texttt{ofstream YY (''minni'')}; che apre il file \texttt{minni}.
\end{enumerate}


L'apertura di un file può fallire. Per esempio, la dichiarazione del punto (ii) fallirebbe se il file \texttt{pippo} aperto in input non fosse presente nella directory corrente. Ci possiamo accorgere del fallimento controllando il valore di \texttt{XX} dopo la sua dichiarazione. Infatti, in caso di fallimento, il valore di \texttt{XX} è 0. L'operazione di apertura può aprire file che si trovano in cartelle qualsiasi (anche diverse da quella corrente), specificando, tra le doppie di virgolette, il cammino per raggiungere il fì le dalla directory corrente. 

Se il file le \texttt{minni} della dichiarazione del punto (iii) non fosse presente nella directory corrente, allora esso verrebbe automaticamente creato. Quindi l'apertura di un file in output difficilmente fallisce. Va tenuto ben presente però che, qualora il file \texttt{minni} esistesse già, la sua apertura in output causerebbe la cancellazione del suo contenuto. L'idea è che un file destinato a ricevere output debba essere inizialmente vuoto. Le modalità di apertura dei file che abbiamo appena presentato sono le più semplici ed esse consentono di aprire file (di testo) da usare in modo strettamente sequenziale. Altre modalità si possono trovare consultando le fonti già citate. 

Quando un file ha esaurito la sua funzione, esso può venire chiuso. Se \texttt{XX} è lo \texttt{stream} associato al file da chiudere, allora XX.\texttt{close();} chiude il file associato a \texttt{XX}. Dal momento in cui questa operazione viene eseguita, \texttt{XX} non è più associato ad alcun file, anche se resta una variabile di tipo \texttt{fstream} che potrà di nuovo venire associata ad un file (lo stesso di prima o diverso), per esempio con l'istruzione \texttt{XX.open(''chi\_vuoi'' );}. 

Per rendere facili le operazioni di i/o che si riferiscono alla tastiera ed allo schermo, nel \texttt{namespace std}, il C++ associa ad essi 2 \texttt{stream} che quindi sono a disposizione dei programmatori. Lo \texttt{stream cin} è associato all'input standard (tastiera), mentre lo \texttt{stream cout} è associato all'output standard (schermo). Nell'Esempio 1.1, abbiamo usato questi 2 \texttt{stream}. 

\subsection{Operazioni di i/o}
Gli stream sono degli oggetti e fanno quindi parte della parte orientata agli oggetti del C++. Ci limiteremo quindi ad usarli senza neppure cercare di spiegarli. Comunque una cosa dobbiamo dirla sugli oggetti: gli oggetti sono delle strutture in cui convivono dei dati e delle funzioni per manipolare questi dati. Nel gergo orientato agli oggetti le funzioni vengono chiamate \textbf{metodi}. Ovviamente i metodi definiti negli stream di i/o sono principalmente operazioni di i/o. Studieremo solo 2 metodi per l'input e 2 metodi per l'output.

\begin{itemize}
\item visto che consideriamo solo file di testo, cioè composti di sequenze di caratteri, è naturale leggere da questi file un carattere alla volta e scrivere su questi file un carattere alla volta. Se XX e YY sono, rispettivamente lo stream di input e quello di output, allora l'istruzione, \texttt{char c=XX.get()}, legge il prossimo carattere (dal file associato a \texttt{XX}). Questo carattere diventa l'R valore della variabile \texttt{c}. Quindi l'operazione di input cambia lo stato del calcolo per quanto riguarda la variabile letta (\texttt{c} nell'esempio). Il file è letto sequenzialmente, quindi la prima \texttt{get} legge il primo carattere del file, la seconda \texttt{get} legge il secondo carattere e così via. La lettura non cambia il contenuto del file. Quindi ad una successiva apertura si ritroverebbe il con­tenuto del file intatto. La scrittura di un carattere può venire effettuata con la seguente istruzione:\texttt{YY.put(c);} il valore di \texttt{c} (variabile di tipo \texttt{char}) viene appeso alla fine del file associato allo \texttt{stream YY}.

\noindent Vale la pena di osservare bene la sintassi delle 2 operazioni appena viste. Per esempio, in \texttt{YY.put(c):YY} è l'oggetto di tipo \texttt{stream} e \texttt{put} è un metodo di questo oggetto. Il punto in \texttt{YY.put(c);} indica proprio l'appartenenza di \texttt{put} allo s \texttt{tream YY} e si chiama operatore di \textbf{appartenenza}. Lo stesso vale per \texttt{char c=XX.get()}.

\item Generalmente i file di testo contengono sequenze di caratteri che rappresentano valori separati da spazi, per esempio sequenze di interi o di reali e sarebbe molto comodo riuscire a leggere (scrivere) un valore intero o reale con un'unica operazione di lettura (scrittura), senza leggere (scrivere) carattere per carattere. Gli \texttt{stream} di i/o offrono operazioni che consentono questa comodità. Esse sono le operazioni $>>$ e $<<$ già viste nell'Esempio 1.1. Vediamo meglio come funzionano. 11 contenuto di un qualsiasi file di testo è una sequenza di stringhe di caratteri separate da caratteri di separazione (spazio e accapo), dove ogni stringa rappresenta un valore per esempio un numero intero oppure un reale. L'istruzione \texttt{XX $>>$ x}; in cui \texttt{x} è una variabile intera, causa la lettura da \texttt{XX} della prossima stringa di caratteri numerici fino al primo separatore che si incontra. Se, anziché caratteri numerici, su \texttt{XX} si trovano altri caratteri, per esempio alfabetici, allora si verifica un errore che spesso causa la non terminazione della lettura. Da questo si può capire immediatamente che la comodità della lettura fatta con $>>$, causa una perdita di robustezza dei programmi, nel senso che si ottengono programmi incapaci di resistere a situazioni impreviste, come trovare caratteri inattesi su \texttt{XX}.

\noindent C'è un'altra particolarità della $>>$ che si deve osservare. Supponiamo che \texttt{x} e \texttt{y} siano variabili \texttt{int}. Se eseguiamo \texttt{XX} $>>$ \texttt{x $>>$ y;} quando il file associato a \texttt{XX} contiene 12 34, allora, dopo la lettura, \texttt{x} avrà R-valore 12 e \texttt{y} 34. Tutto normale? Forse, ma occorre notare che il contenuto del file è in realtà la seguente sequenza di caratteri: \texttt{'1' '2' ' ' '3' '4'} e quindi la lettura ha saltato il carattere spazio ' ' il che è coerente col fatto che esso funge da separatore. Insomma con la $>>$ non si possono leggere i caratteri di separazione contenuti nel file (spazi e accapo). Quanto appena descritto è vero anche se la lettura concerne una variabile di tipo \texttt{char}, come in, \texttt{char c; XX $>>$ c;}. Anche in questo caso non vengono letti i caratteri di separazione (spazi e accapo). Un programma che mostra in modo chiaro questo fenomeno e lo contrasta con quello che succede con l'operazione \texttt{get}, è discusso negli Esercizi 3.5, 3.6 e 3.7.

\noindent Riconsideriamo l'esempio precedente. Se \texttt{x} è intera, la lettura, \texttt{XX} $>>$ \texttt{x;} trasforma automaticamente i caratteri \texttt{'l'} e \texttt{'2'}, presenti sul file, nella rappresentazione interna dell'intero 12 (cioè con 4 byte in complemento a 2) e questo diventa l'R-valore di \texttt{x}. Questo significa che il tipo della variabile che viene letta (cioè \texttt{int} nell'esempio) determina quale sequenza W di caratteri ci deve essere sul file di input perché l'operazione di lettura riesca normalmente. La lettura che riesce trasforma \textit{W} nella rappresentazione interna del valore rappresentato da \textit{W}. Quindi se nel file, anziché \texttt{'l'} e \texttt{'2'} ci fosse \texttt{'1'} , \texttt{'.'} e \texttt{'2'}, allora la lettura avrebbe un comportamento anomalo (provare per credere) perché il tipo \texttt{int} non prevede un punto nei suoi valori. Se invece \texttt{x} avesse tipo \texttt{double} la lettura funzionerebbe normalmente e \texttt{x} assumerebbe l'R-valore \texttt{1.2} (rappresentato in modo floating point con 8 byte). Nel caso in cui \texttt{x} avesse tipo \texttt{double} ed il file contenesse \texttt{'l' '2' ' ' '3' '4'}, allora verrebbe calcolata la rappresentazione floating point su 8 byte di 12 ed assegnata come R-valore a \texttt{x}.

\noindent In conclusione, l'operazione di lettura $>>$ si \textit{fida} del tipo della variabile letta per sapere quali caratteri aspettarsi sul file (fragilità), e traduce la stringa di caratteri letta nella rappresentazione interna appropriata al tipo della variabile letta (comodità). Quindi l'operazione di lettura $>>$ è comoda, ma fragile. Se le aspettative determinate dal tipo della variabile letta non si avverano, la lettura può avere risultati anomali. Da questo segue che ogni applicazione rivolta ad utenti qualsiasi non potrà mai effettuare letture con $>>$. Dovrà sempre leggere l'input come sequenza di caratteri e successivamente verificare che la sequenza letta corrisponda alle attese o no.

\noindent Anche l'operazione di output $<<$ esegue automaticamente una traduzione, ma in senso inverso rispetto a quella dell'input. Infatti, essa traduce l'R-valore della variabile da stampare (naturalmente si tratta della rappresentazione interna al computer del valore) nella sua rappresentazione esterna, cioè nella sequenza di caratteri che la rappresenta, ed è questa rappresentazione che viene scritta sul file. Ogni nuova operazione di output inserisce un nuovo valore dopo quelli stampati in precedenza senza lasciare spazi o accapo tra un valore ed il successivo. Se non si inseriscono esplicitamente separatori, si rischia di ottenere un file che sarebbe impossibile leggere successivamente.

\end{itemize}

\paragraph{Esercizio 3.1} 
\textit{Realizzare un programma che crea un file di testo in output, scrive,
(con $>>$), su questo file i valori interi 11, 32, 455 e 6, chiude il file, lo riapre in
input e cerca di leggere dal file i 4 valori interi appena scritti. Per finire chiude il
file definitivamente. Attenzione a separare i valori quando li scrivete!}

Come spiegato in precedenza, la lettura sequenziale di un file fa in modo che ad ogni operazione di lettura venga letto il prossimo byte (o gruppo di byte). Insomma è come se sul file ci fosse un segno che avanza ad ogni lettura per indicare il prossimo byte che verrà letto. Prima o poi questo segno arriverà alla fine del file, cioè all'end of file, e chiaramente, una volta raggiunto quel punto, successive letture non avrebbero senso. Segnaliamo che tali letture, benché erronee (in generale) non causano l'interruzione dell'esecuzione del programma, ma leggono valori sballati.
\noindent Lo \texttt{stream} associato al file ci offre il metodo \texttt{eof()} (eof abbrevia end of file) che restituisce il booleano \texttt{true} solo quando la fine del file è stata raggiunta. Per un \texttt{ifstream XX} si controlla di aver raggiunto la fine del file con la seguente invocazione: \texttt{XX.eof();}. Si deve fare attenzione al fatto che le diverse operazioni di lettura introdotte in Sezione 3.1.3 possono presentare un comportamento diverso rispetto al raggiungimento dell'end of file. Questo fenomeno è illustrato nell'Esempio 3.5.

Sull'input/output ci sarebbero molte altre cose da dire. Per esempio gli \texttt{stream} di input ci offrono anche altre operazioni di input come la \texttt{getline} che legge i prossimi caratteri sullo \texttt{stream} fino al primo carattere di accapo. Inoltre ci so­no anche operazioni di output formattato, in cui è possibile fissare il numero di spazi disponibili per la stampa di un dato valore. È interessante anche sapere che esiste la possibilità di definire file su cui è possibile sia leggere che scrive­re dati e su cui queste operazioni non sono necessariamente sequenziali. Queste cose non ci serviranno nel seguito del libro. I lettori possono trovare informazioni su questi aspetti tecnici dell'input/output su internet, per esempio all'indirizzo: \texttt{www.cplusplus.com}. 

\section{Assegnazione}
L'istruzione più semplice, ma comunque più importante, del C++ è \textbf{l'assegnazione}.

\noindent L'assegnazione ha la forma, \texttt{x= (2*y) / (3*z);} in cui \texttt{x}, \texttt{y} e \texttt{z} sono variabili.

\noindent L'esecuzione di una tale assegnazione produce il seguente effetto. Supponiamo che lo stato del calcolo al momento precedente l'esecuzione dell'assegnazione sia \textbf{S}, allora viene calcolato il valore \texttt{v} di \texttt{(2*}\textbf{S}\texttt{(y)) / (3*}\textbf{S}\texttt{(z))} (si ricordi che \textbf{S}\texttt{(y)} è l'R-valore di \texttt{y} nello stato \textbf{S}) e \texttt{v} diventa l'R-valore di \texttt{x}. Quindi, dopo l'esecuzione di questa assegnazione, il nuovo stato del calcolo sarà \textbf{S'} che è uguale a \textbf{S} per ogni variabile diversa da \texttt{x} e uguale a \texttt{y} per \texttt{x}. Si osservi che tra le variabili che appaiono nell'espressione a destra dell'uguale di un'assegnazione può esserci anche la variabile che appare alla sinistra dell'uguale. Come per esempio in \texttt{x=(2*y)/(3*x);}. L'esecuzione di una tale assegnazione non ha nulla di diverso dalla precedente. 

La descrizione di quanto avviene durante l'esecuzione di un'assegnazione spiega (finalmente) i nomi R- e L-valore delle variabili. Infatti abbiamo appena visto che per la valutazione dell'espressione a destra del segno di uguale si usano gli R-valori delle variabili che vi appaiono (e destra e Right in inglese), mentre il valore v di questa valutazione viene immagazzinato nella RAM all'indirizzo che è l'L-valore della variabile che appare alla sinistra dell'assegnazione (e sinistra è Left in inglese). 

Il C++ consente di scrivere assegnazioni in forme abbreviate come, \texttt{potenza*= 2;} e \texttt{esponente++;}. Esse corrispondono alle seguenti assegnazioni normali: \texttt{potenza* = 2; $\Rightarrow{}$ potenza = potenza*2;} e 

\noindent \texttt{esponente++; $\Rightarrow{}$ esponente = esponente + 1;}

\noindent Lo stile abbreviato di queste assegnazioni proviene dal C ed aveva originalmente il duplice scopo di permettere di scrivere codice conciso e anche di ottenere codice oggetto più efficiente. In realtà i compilatori moderni non hanno bisogno delle forme abbreviate per ottimizzare il codice che producono e quindi la forma abbreviata è ora motivata solo dalla ricerca della concisione del codice e forse dall'abitudine. Nel seguito useremo spesso gli operatori \texttt{++} e \texttt{$--$} sia in forma postfissa che prefissa, come per esempio in \texttt{esponente++;} e \texttt{++esponente;}. Entrambi questi comandi effettuano l'assegnazione \texttt{esponente = esponente + 1;} e non c'è alcuna differenza tra i 2 comandi se essi sono usati da soli, mentre c'è differenza se essi vengono usati all'interno di un'espressione più complessa. Consideriamo un semplice esempio: confrontiamo l'effetto di eseguire \texttt{int x=l; x=(x++)*2;} con quello di eseguire \texttt{int x=1; x=(++x)*2;}. Nel primo caso, dopo l'esecuzione, il valore di \texttt{x} è 3, mentre nel secondo caso il valore di \texttt{x} diventa 4. li motivo è che nel primo caso l'incremento richiesto da \texttt{x++}, viene eseguito dopo l'assegnazione \texttt{x=1*2} e quindi il valore finale di \texttt{x} è 3, mentre nel secondo caso l'incremento richiesto da \texttt{++x} viene fatto immediatamente e quindi l'assegnazione diventa \texttt{x = 2*2}.

\section{Condizionale}
La prossima istruzione da considerare è l'istruzione condizionale. Essa ha la for­ma, \texttt{if (EXP) Cl else C2;} dove \texttt{Cl} e \texttt{C2} sono blocchi di istruzioni e \texttt{EXP} è un'espressione booleana, cioè un'espressione il cui valore è di tipo \texttt{bool}. In realtà, visto che il C++ \textit{confonde} \texttt{bool} con \texttt{int} (con 0 equivalente a \texttt{false} e tutti gli altri valori interi equivalenti a \texttt{true}), \texttt{EXP} può avere anche un valore \texttt{int}. L'esecuzione di questa istruzione in un certo stato del calcolo \textbf{S} ha il seguente effetto: viene calcolato il valore dell'espressione booleana \texttt{EXP} nello stato del calcolo \textbf{S} e se questo valore è \texttt{true} (o un qualsiasi intero diverso da 0), allora viene eseguito il blocco di istruzioni \texttt{Cl}, altrimenti viene eseguito \texttt{C2}. In entrambi i casi, dopo l'esecuzione di \texttt{Cl} o \texttt{C2} il calcolo continua con l'istruzione che segue il condizionale. La Figura 3.1 contiene il diagramma a blocchi del condizionale nella sua forma completa con entrambi i rami \texttt{Cl}, detto tradizionalmente il ramo \texttt{then}, e \texttt{C2}, detto il ramo \texttt{else} ed anche nella forma con il solo ramo \texttt{then}. 

\section{Cicli while}
Ogni linguaggio di programmazione che si rispetti deve possedere un'istruzione iterativa che permette di ripetere un certo blocco di istruzioni per tutto il tempo che una data condizione è verificata. Senza una tale istruzione iterativa (o qualcosa di analogo) un linguaggio è incapace di realizzare calcoli realmente interessanti.

L'istruzione iterativa più semplice del C++ è il \texttt{while} che ha la seguente forma: \texttt{while (EXP) C};, in cui \texttt{EXP} rappresenta un'espressione booleana (o interpretabile come booleana) e \texttt{C} è un blocco di istruzioni. \texttt{EXP} è detta la \textbf{condizione} di permanenza nel ciclo, mentre \texttt{C} è il \textbf{corpo} del \texttt{while}.

L'effetto di eseguire questa istruzione in uno stato del calcolo \textbf{S} è come segue: viene calcolato il valore dell'espressione booleana \texttt{EXP} nello stato del calcolo \textbf{S} e se esso ha valore \texttt{true} (o intero diverso da 0) allora viene eseguito il blocco \texttt{C}. L'esecuzione del corpo generalmente cambia lo stato da \textbf{S} in \textbf{S'} ed in questo nuovo stato si torna ad eseguire \texttt{while (EXP) C;}. Se in \textbf{S'} \texttt{EXP} è ancora \texttt{true} allora si esegue di nuovo il corpo e così via. Prima o poi (sperabilmente) si raggiunge uno stato del calcolo \textbf{S''} tale che in questo stato \texttt{EXP} abbia valore \texttt{false} e allora l'esecuzione del \texttt{while (EXP) C;} termina ed il calcolo continua dall'istruzione che segue immediatamente il corpo del \texttt{false}. Lo stato del calcolo alla fine del ciclo sarà \textbf{S''}.

Può capitare che \texttt{EXP} non diventi mai \texttt{false}. In questo caso (a meno di istruzioni di salto contenute nel corpo) l'esecuzione non esce mai dal \texttt{false} e questo fenomeno viene chiamato un \textbf{ciclo infinito}. Ovviamente quando questo succede siamo in presenza di un programma errato. Il diagramma a blocchi del \texttt{false} è in Figura 3.2. Nella stessa Figura 3.2 viene anche illustrata la variante \texttt{do-while} del \texttt{while} che esegue il corpo sempre almeno una volta visto che valuta l'espressione \texttt{EXP} solo dopo questa prima esecuzione del corpo. 

\section{Esempi}
Illustriamo ora le nuove istruzioni appena introdotte realizzando alcuni semplici programmi. Iniziamo modificando l'Esempio 1.1.

\paragraph{Esercizio Risolto 3.2}
\textit{Dopo aver letto 2 valori dallo \texttt{stream} di input \texttt{cin} ed averli assegnati alle variabili \texttt{x} e \texttt{y}, vogliamo sommare i due valori ed assegnare questo valore ad una nuova variabile intera \texttt{SOM} e per ultimo, usando l'istruzione condizionale, se il valore di \texttt{SOM} è maggiore di 0 vogliamo assegnare il valore di \texttt{SOM} ad \texttt{y}, altrimenti, (cioè se \texttt{SOM} $\le$ 0), vogliamo assegnare \texttt{SOM} a \texttt{x}. Il programma che compie queste azioni segue. Esso ci mostra alcune cose interessanti.
Per esempio che le dichiarazioni possono essere in qualsiasi punto di un blocco, cf. la dichiarazione di \texttt{SOM}. Inoltre il programma illustra l'uso del condizionale che ci consente di fare cose diverse a seconda dello stato del calcolo in cui ci troviamo. Per esempio assumiamo che i valori letti per \texttt{x} e \texttt{y} siano 2 e -4. Allora \texttt{SOM} assume il valore 2-4=-2 e quindi la condizione \texttt{SOM>0} in questo stato del calcolo è falsa e quindi viene eseguito il ramo \texttt{else} del condizionale cioè l'assegnazione \texttt{x=SOM}. Per cui lo stato finale \textbf{S} è come segue: \texttt{S(x)=-2, S(y)=-4 e S(SOM)=-2}. Se invece di 2 e -4 dallo \texttt{stream} di input vengono letti i valori 5 e -4 le cose sarebbero andate diversamente? In che modo?}

\begin{codice}

#include<iostream> 
using namespace std; 
main() {
  int x, y; 
  cout << "inserire 2 interi"; 
  cin >> x >> y; 
  cout<<"valore di X="<< x <<"valore di y="<< y;
  int SOM; 
  SOM= x+y; 
  if (SOM > 0) 
    y=SOM;
  else
    x=SOM;
  cout<<"valore di x="<< x <<"valore di y="<< y;
}
\end{codice}

\paragraph{Esercizio Risolto 3.3}
\textit{Consideriamo ora di voler leggere degli interi dall'input standard fino a che non si legge il valore 0 e dei valori letti si vuole calcolare quanti sono positivi e quanti negativi (quindi lo 0 non viene contato). Benché l'esercizio sia semplice proponiamo due diverse soluzioni, una che usa un ciclo \texttt{while} ed una seconda con un \texttt{do-while}, vedi Figura 3.2. La prima soluzione è la seguente:}

\begin{codice}
#include<iostream> 
using namespace std; 
main() { 
  int pos=0, neg=0, x; cin>>x; 
  while (x != 0) {
    if(x < 0)
      neg=neg+1;
    else
      pos=pos+1;
    cin>>x;
  }
  cout<<"neg="<< neg <<" pos="<<pos<<endl;
}
\end{codice}


\noindent \textit{Un punto da notare è che \texttt{neg} e \texttt{pos} vanno inizializzati a 0 prima di essere usati, altrimenti otterremmo dei valori casuali o comunque sbagliati. Si noti anche che la prima lettura viene fatta prima di entrare nel ciclo in modo da avere la variabile \texttt{x} pronta per il test di permanenza nel ciclo. Le successive letture sono eseguite alla fine del corpo del ciclo cioè immediatamente prima di tornare alla valutazione del test di permanenza. Il fatto che serva una lettura fuori dal ciclo ed una nel ciclo, indica che probabilmente il problema può essere risolto in maniera più naturale con un ciclo \texttt{while-do} che permette di fare anche la prima lettura nel corpo del ciclo visto che il test di permanenza è alla fine del ciclo stesso. Questa soluzione alternativa segue.}

\begin{codice}
#include<iostream> 
using namespace std; 
main() { 
  int pos=0, neg=0, x; cin>>x; 
  do {
   cin>>x;
   if (x < 0)
     neg=neg+1;
   else
     if(x>0)
       pos=pos+1;
  } while(x!=0);
  cout<<"neg="<< neg <<" pos="<<pos<<endl;
}
\end{codice}

\noindent \textit{Come previsto questa soluzione necessita di una sola lettura anziché due come nella soluzione precedente. Però questa semplificazione la si paga con la necessità di un condizionale più complicato nel corpo del ciclo. Infatti, dopo la lettura, \texttt{x} potrebbe essere 0 nel qual caso non dobbiamo cambiare né \texttt{neg} né \texttt{pos} e, per garantire questa condizione, siamo obbligati ad avere il test \texttt{x>0} nel ramo \texttt{else} in modo da escludere il caso \texttt{x=0}. Forse per questo semplice problema si può pensare che sia ovvio che le nostre 2 soluzioni siano giuste, ma in generale non è cosi e ci sarà bisogno di ragionare per arrivare ad una soddisfacente convinzione della correttezza dei nostri programmi. Nel prossimo Capitolo, questo esempio ci servirà da apripista per mostrare come questi ragionamenti possono venire organizzati.}

\paragraph{Esercizio Risolto 3.4}
\noindent \textit{Si vuole realizzare un programma che legge 10 interi dal­l'input standard, memorizza il minimo e il massimo tra i valori letti e alla fine li stampa sull'output standard li programma deve avere un ciclo \texttt{while} che esegue 10 volte e che dopo aver letto il prossimo intero lo confronta con il massimo ed il minimo tra i valori letti in precedenza e li modifica a seconda dei casi. Chiamiamo le due variabili i cui R-valori sono, rispettivamente, il massimo ed il minimo tra i valori letti in precedenza, \texttt{max} e \texttt{min}. Sembra semplice, ma c'è un problema. Alla prima esecuzione del \texttt{while}, non abbiamo ancora letto alcun valore e quindi che valore dovranno avere \texttt{max} e \texttt{min}? Questo problema si presenterà spesso in altri esercizi proposti nel seguito. Lo affronteremo in modo completo subito. Possiamo assegnare a \texttt{max} e \texttt{min} dei valori ad hoc che fanno funzionare le cose, oppure leggere il primo valore (sappiamo che c'è visto che sono previste 10 letture) e assegnarlo sia a \texttt{max} che a min e dopo leggere gli altri 9 valori. Pensiamo prima alla soluzione con i valori ad hoc. Per max abbiamo bisogno di un valore che sarà certamente minore o uguale di ogni valore intero che potremo leggere. Questo va­lore è ovviamente INT_MIN: il minimo intero rappresentabile. Analogamente, per min, il valore giusto è INT..MAX. Vediamo un programma che segue questa idea.}






























\end{document}